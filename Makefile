# The following Makefile has been adapted from:
#
#     https://akdiem.wordpress.com/2013/03/15/the-simplest-most-useful-makefile-latex/
#
# The beamertheme-metropolis package uses special fonts so we must use xelatex instead
# of pdflatex.  Compiling with xelatex also allows you use utf-8 characters directly in
# your .tex file, allowing you to directly type things like chinese characters or
# accents.  Most of the time, though, you can get away with using pdflatex.
#
# The --shell-escape option is needed for certain code listings e.g. minted, as well as
# some plotting libraries e.g. pgfplot.
LATEX  := xelatex --shell-escape
BIBTEX := bibtex

# This Makefile assumes there is a directory structure:
#
# ./
#     - Makefile (this one)
#     <directory01>/
#         - <single source>.tex
#     <directory02>/
#         - <single source>.tex
#     ...
#
# In words, that there are some number of directories with exactly one .tex file n each
# directory.  The goal is to compile each <directory>/<single source>.tex into
# <directory>/<single source>.pdf.
SINGLE_SOURCE := $(shell find . -name "*.tex") # find all .tex files
NO_EXTENSIONS := $(basename $(SINGLE_SOURCE))  # make basename gives the path without the extension
COMPILED_PDFS := $(SINGLE_SOURCE:.tex=.pdf)    # change <single source>.tex to <single source>.pdf

# Defining the `all` rule enables you to just type `make` in the same directory as the
# Makefile.  If it is not defined, the first rule defined will be executed when you
# only type `make`. We make `all` depend on the expansion of COMPILED_PDFS so that
# `all` will not be finished until every one of the rules in COMPILED_PDFS (below) is
# also finished.
all: $(COMPILED_PDFS)

# This defines a rule for each file in the list COMPILED_PDFS.  So if COMPILED_PDFS was
# the list
#
#     lecture01/lecture01.pdf lecture02/lecture02.pdf
#
# then this would create the targets
#
#     lecture01/lecture01.pdf: lecture01/lecture01.tex
#     lecture02/lecture02.pdf: lecture02/lecture02.tex
#
# Since we want to compile the results in the respective folders (as opposed to the
# folder where this Makefile is), the jobname needs to be specified as such.  Refer to
# the following for what the automatic variables are:
#
#     https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html
#
# IMPORTANT:
# File path issues with bibtex are common, and there do not exist many simple ways to
# use relative paths from within the .tex file.  The solution I use is that each .tex
# file provides a path to the .bib file being used relative to this Makefile.  For
# example, if I have the directory structure
#
# ./
#     - Makefile (this one)
#     lecture01/
#         - lecture01.tex
#         - references.bib
#
# then in order for me to use references.bib inside of lecture01.tex, I need to use the
# command
#
#     \bibliography{lecture01/references}
#
# in order for the references to be included / compiled correctly.
$(COMPILED_PDFS): %.pdf: %.tex
	$(LATEX)  --jobname=$(basename $@) $<
	$(LATEX)  --jobname=$(basename $@) $<

	@# If no \bibliography is included, we do not want to execute bibtex as it will fail.
	@# The following greps for '\bibliography{' in the current .tex file, and counts the
	@# number of lines that do not have the comment character '%' before it.  See
	@#
	@#     http://unix.stackexchange.com/questions/60994/how-to-grep-lines-which-does-not-begin-with-or
	@#
	@# for an explanation of the second grep expression.  Lastly, see the following
	@#
	@#     https://www.gnu.org/software/make/manual/html_node/Echoing.html
	@#
	@# for why these comments have an @ in front of them.  Normally you do not have to
	@# do this for comments, but since these comments are inside of a target definition
	@# you do.  The make echoing behavior is observed most easily if you execute
	@# `make realclean` with this makefile.
	if [ "$(shell grep '\\bibliography{' $< | grep -c -v ^[[:space:]]*[\%])" -gt "0" ]; then \
		$(BIBTEX) $(basename $@); \
	fi

	$(LATEX)  --jobname=$(basename $@) $<
	$(LATEX)  --jobname=$(basename $@) $<

# Defining clean targets is a common practice, allowing the user to cleanup the files
# generated during compilation with ease.  The `clean` target will get rid of the
# intermediate compilation files, and the `realclean` target will do this as well as
# remove the PDF files.
#
# The EXTENSIONS list is a list of the intermediate files that will be produced.  The
# CLEANABLES list is generated by looping over all of the elements in NO_EXTENSIONS
# defined above, and for each one of those will add to the list each one of the
# extensions listed in EXTENSIONS.
EXTENSIONS := .aux .blg .out .bbl .log .nav .snm .toc .vrb .pyg
CLEANABLES := $(foreach file, $(NO_EXTENSIONS), \
                  $(foreach ext, $(EXTENSIONS), \
                      $(file)$(ext)))

.PHONY: clean realclean
clean:
	rm -f $(CLEANABLES)

realclean: clean
	rm -f $(COMPILED_PDFS)
